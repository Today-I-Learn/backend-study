### 페이징과 세그멘테이션에 대해서 설명해주실 수 있나요?

페이징이란 메모리와 프로세스를 페이지라는 동일한 크기로 분할하는 것을 의미하며 일반적으로 하나의 페이지 크기를 4KB로 설정합니다. 페이징을 통해 고정할당 방식의 문제점인 내부, 외부 단편화 문제를 해결할 수 있지만
프로그램의 마지막 부분에는 내부 단편화가 발생할 수도 있습니다. 

페이징은 CPU가 사용하는 논리적 주소 방식을 주소 변환을 통해 실제 물리적 주소로 맵핑하는 과정을 거치게 됩니다. 이 때 논리적 주소는 페이지 번호와 오프셋으로 나누어지게 되는데 페이징 과정에서 페이지 번호는 페이지 테이블에
접근시 인덱스로 사용되며 해당 인덱스 항목에 접근하여 물리적 메모리 상의 기준 주소를 찾아 오프셋을 더하는 방식으로 물리적 주소를 계산하게 됩니다. 

페이징 방식에서는 `TLB, Table Look-asid Buffer` 라는 것을 통해 빈번히 참조되는 페이지에 대한 주소 변환 정보를 저장해두어 메모리에 두번 접근해야하는 페이징 방식의 단점을 개선하고 있습니다. 이 때 CPU는 
1차적으로 `TLB` 에 참조되는 페이지에 대한 주소가 있는지 먼저 조회하고 없을 경우 페이지 테이블에 조회하는 과정을 거치게 됩니다.

<br>

세그멘테이션은 페이징과 다르게 주소 공간을 코드, 데이터, 스택 등의 기능 또는 의미 단위로 나눈 것을 의미합니다. 세그멘테이션은 페이징과 마찬가지로 프로세스의 주소공간이 나누어져 각각 메모리에 적재된다는 면에서는 동일하지만 
프로그램을 세그먼트 단위로 나누어 관리하기 때문에 크기가 균일하지 않습니다. 

세그멘테이션에서는 주소 변환을 위해 세그먼트 테이블을 이용하여 논리적 주소를 물리적 주소로 맵핑하고 있습니다. 세그먼트 테이블의 각 항목은 기준점과 한계점을 가지고 있으며 각각은 물리적 메모리에서 세그먼트의 시작 위치와 세그먼트의 길이를 나타내게 됩니다.
이 때 세그먼트의 길이를 나타내는 한계점이 필요한 이유는 세그먼트의 길이가 동일하지 않기 때문입니다. 

세그먼테이션에서는 논리적 주소를 물리적 주소로 변환하기 전에 요청된 세그먼트 번호가 세그먼트 테이블에 저장된 값보다 작은 값인지, 논리적 주소의 오프셋 값이 세그먼트의 길이보다 작은 값인지를
비교하는 과정을 거치게 됩니다. 만약 이러한 경우에서 물리적 메모리의 유효한 위치에 대한 접근이 아닌 경우에는 예외를 발생시켜 해당 메모리 위치에 대한 접근을 차단하게 됩니다.

<br> 

### 페이징과 세그멘테이션의 장점과 단점은 무엇인지 이를 개선한 방법에는 어떠한 것이 있는지 설명해주실 수 있나요?

세그멘테이션과 페이징의 각각의 장단점을 가지고 있으며 각자의 장점이 다른 한쪽의 단점으로써 작용하고 있습니다. 세그멘테이션 방법은 의미단위로 나누어져 있기 때문에 공유와 보완 측면에서 페이징 기법에 비해서 훨씬 효과적이지만 의미단위로 프로그램을 나누기 때문에 외부 단편화가 발생할 수 있다는 단점이 있습니다.
때문에 이러한 두 가징 방법의 장점만을 위한 페이지드 세그멘테이션 기법이 존재합니다.

페이지드 세그멘테이션 기법은 의미 단위의 세그먼트로 프로그램을 나누는 것은 동일하지만 각각의 세그먼트들이 임의의 길이를 가지는 것이 아닌 페이지의 배수가 되는 동일한 크기들의 집합으루 구성하며 이와 동시에 물리적 메모리에 적재하는 단위를 페이지 단위로 함으로써 외부 단편화 문제를 해결하고 
프로세스 간의 공유나 프로세스 내의 접근 권한 보호가 이루어지도록 함으로써 페이징의 단점을 개선하고 있습니다.
