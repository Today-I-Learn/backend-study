### 스케줄링 알고리즘에 대해 설명할 수 있나요?

#### 1. FCFS (First Come First Serve)

특징 
- 먼저 도착한 프로세스를 먼저 처리하는 알고리즘입니다. 또한, '비선점형'이며 FIFO를 이용하여 구현합니다.

단점 
- 응답시간이 길어질 수 있으며 Convey Effect(호위 효과) 즉, Short process behind long process, 
  긴 처리시간의 프로세스가 선점되어버리면 나머지 프로세스들은 끝날때 까지 대기해야 합니다. 따라서 평균 대기시간의 편차가 큽니다.<br>

#### 2. SJF(Shorted Job First)

특징 
- CPU burst time이 짧은 작업을 우선으로 할당하는 방법입니다. 
- 가장 적은 평균 대기 시간을 달성할 수 있습니다. 
- 만약 CPU버스트 시간이 동일하다면 FCFS방식을 따릅니다. 
  다만 선점형인 경우에는 위와같이 진행이 되지만 비 선점형일 경우엔 최소잔여시간우선(SRTF) 법칙을 따릅니다. 
  
단점 
- 기아현상이 발생할 가능성이 있습니다.<br>

#### 3. SRTF (Shortest Remaining Time First)

특징 
- SJF의 선점형 스케줄링 방식입니다. 
- 남은 프로세스의 burst time보다 더 짧은 process가 도착하면 CPU를 빼앗습니다. 또한, 프로세스가 새로 들어올때마다 갱신됩니다. 

단점 
- 기아현상이 생깁니다. 
- 새로운 프로세스가 들어올때마다 스케줄링이 변경되므로 CPU 사용 시간(burst time)을 정확히 예측하기 어렵습니다. <br>

#### 4. RR (Round Robin)

특징 
- 시분할 시스템을 위해서 설계된 '선점형' 스케줄링 기법입니다. 
- 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 가지고, 할당 시간이 지나면 프로세스는 선점 당하고 Ready queue의 맨 뒤로 가게 됩니다.
- 문맥교환을 통해 프로세스의 Context를 저장할 수 있기 때문에 가능한 기법입니다.
- CPU 사용시간이 랜덤할때 더욱 효율적입니다. 또한, 평균 대기 시간(Average Waiting Time)은 조금 길어질 수 있으나, 응답시간(Response)이 짧아집니다.
- 프로세스가 기다리는 시간이 CPU 를 사용할 만큼 증가합니다 따라서 공정한 스케줄링이라고 할 수 있습니다. 

단점 
- 시간 할당량이 작을수록 문맥교환이 자주 일어나서 많은 Overhead가 발생합니다. 
- 반면에 너무 길면 FCFS와 다를바 없어집니다.<br>

#### 5. Priority Scheduling
특징
- 우선순위가 가장 높은 프로세스에게 CPU 를 할당하는 스케줄링입니다. 우선순위란 정수로 표현하게 되고 작은 숫자가 우선순위가 높습니다.
- '선점형' 방식에서는 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU 를 선점합니다.
- '비선점형' 방식에서는 더 높은 우선순위의 프로세스가 들어오면 Ready queue의 head 부분에 넣습니다. 

단점
- 기아현상 
- 무한 정지(infinite blocking) : 프로세스가 CPU를 사용할 준비가 되었지만 우선순위가 낮을 경우 무한 대기하는 상태가 되는 것
  (Aging 기법으로 큐에 남아있었던 시간으로 가중치를 부여해 문제를 해결할 수 있습니다.) <br>

#### 6. MLQ (MultiLevel Queue Scheduling)
특징
- 우선순위마다 준비 큐를 형성합니다.
- 항상 가장 높은 우선순위 큐의 프로세스에 cpu를 할당합니다.(우선순위가 낮은 큐에서 작업 실행 중이더라도 상위 단계의 큐에 프로세스가 도착하면 CPU를 빼앗는 선점형 스케줄링)
- 각 큐는 라운드 로빈이나 FCFS등 독자적 스케줄링 사용 가능합니다.

단점
- 큐들 간의 프로세스 이동이 불가하기 때문에 스케줄링 부담이 적지만 유연성이 떨어집니다.
- 우선순위가 낮은 프로세스가 오랬동안 CPU 할당을 기다리는 기아 현상이 발생할 수도 있습니다. <br>

### 7. MLFQ (MultiLevel Feedback Queue Scheduling)
특징
- 프로세스 생성 시 가장 높은 우선 순위 준비 큐에 등록되며 CPU를 할당받아 실행됩니다.
  해당 큐의 CPU 시간 할당량(Time Quantum)이 끝나면 한 단계 아래의 준비 큐에 들어갑니다. 
- 우선순위가 높은 단계의 큐일수록 시간 할당량(Time Quantum)이 작습니다.
- 큐 사이의 프로세스 이동 가능하며 CPU Burst는 낮은 우선순위의 큐, I/O Burst는 높은 우선순위의 큐에 배치합니다.
- 가장 우선순위가 낮은 큐는 FCFS 스케줄링입니다. 나머지는 RR 스케줄링 기법을 사용합니다.
- 맨 아래 큐에서 너무 오래 대기하면 다시 상위 큐로 이동합니다 (에이징 기법을 통한 기아상태 예방가능합니다.)

고려사항
- 큐(Queue)의 수.
- 각 큐에 대한 스케줄링 알고리즘.
- 작업을 좀 더 높은 우선순위의 큐로 격상시키는 시기를 결정하는 방법.
- 작업을 좀 더 낮은 우선순위의 큐로 격하시키는 시기를 결정하는 방법.
- 프로세스들이 어느 큐에 들어갈 것인가를 결정하는 방법.
- 프로세스가 서비스를 받는 시기를 결정하는 방법. <br>

#### MLQ VS MLFQ
- MLQ는 큐와 큐 사이에 프로세스들이 이동할 수 없지만 MLFQ는 이동 가능합니다. 
- MLQ가 MLFQ보다 스케줄링 부담이 적지만 유연성은 떨어집니다.
- MLQ는 기아현상이 발생할 수 있지만 MFQ는 에이징 기법을 통해 기아현상을 예방 가능합니다.
